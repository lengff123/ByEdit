<!DOCTYPE html>
<html lang="en">
<head>
    <title>ByEdit - åŒæ­¥ç¼–è¾‘å™¨</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --error-color: #f44336;
            --bg-color: #f5f5f5;
            --border-color: #ccc;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: #fff;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5em;
            color: #333;
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .editor-div {
            flex: 1;
            width: 100%;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            padding: 15px;
            box-sizing: border-box;
            border: none;
            outline: none;
            transition: background-color 0.3s;
            white-space: pre-wrap;
            overflow-y: auto;
        }

        .editor-div:disabled {
            background-color: #fff;
            color: #000;
            opacity: 0.8;
        }

        #editor.dragover {
            background-color: rgba(76, 175, 80, 0.1);
            border: 2px dashed var(--primary-color);
        }

        #editor:disabled {
            background-color: #fff;
            color: #000;
            opacity: 0.8;
        }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }

        .connected { 
            background-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .disconnected { 
            background-color: var(--error-color);
            box-shadow: 0 0 10px var(--error-color);
        }

        #backups-panel {
            width: 250px;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: fixed;
            right: -270px;
            top: 80px;
            transition: right 0.3s ease;
            z-index: 1000;
        }

        #backups-panel.show {
            right: 20px;
        }

        #backups-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2em;
        }

        #backup-list {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        .placeholder-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            pointer-events: none;
            text-align: center;
        }

        .placeholder-text i {
            display: block;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .shortcut-tip {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .shortcut-tip.show {
            opacity: 1;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“</text></svg>">
</head>
<body>
    <div class="header">
        <h1>ByEdit åŒæ­¥ç¼–è¾‘å™¨</h1>
        <div id="status" class="status"></div>
    </div>

    <div class="main-container">
        <div class="editor-container">
            <div id="editor" contenteditable="true" spellcheck="true" class="editor-div"></div>
            <div class="placeholder-text">
                <i class="fas fa-file-import"></i>
                æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æ‰“å¼€
            </div>
        </div>

        <div id="backups-panel">
            <h3><i class="fas fa-history"></i> å†å²å¤‡ä»½</h3>
            <select id="backup-list"></select>
            <button onclick="restoreBackup()">
                <i class="fas fa-undo"></i> æ¢å¤
            </button>
        </div>
    </div>

    <div class="shortcut-tip" id="shortcut-tip">æŒ‰ Ctrl+B æ˜¾ç¤º/éšè—å¤‡ä»½é¢æ¿</div>

    <script>
        console.log("é¡µé¢åŠ è½½å¼€å§‹");

        let ws = null;
        let isUpdating = false;
        let fileHandle = null;
        let syncInterval = null;
        const editor = document.getElementById('editor');
        const status = document.getElementById('status');

        const INTERVALS = {
            TYPING: 30,        // ä» 50ms å‡å°‘åˆ° 30ms
            ACTIVE: 500,       // ä» 1500ms å‡å°‘åˆ° 500ms
            IDLE: 1000,        // ä» 3000ms å‡å°‘åˆ° 1000ms
            INACTIVE: 2000     // ä» 5000ms å‡å°‘åˆ° 2000ms
        };
        let lastEditTime = Date.now();
        let currentSyncInterval = INTERVALS.INACTIVE;
        const TYPING_INTERVAL = 1000;
        let typingTimer;
        let lastContent = '';

        // æ·»åŠ å¿«æ·é”®å¤„ç†
        document.addEventListener('keydown', (e) => {
            // Ctrl+B åˆ‡æ¢å¤‡ä»½é¢æ¿
            if (e.ctrlKey && e.key.toLowerCase() === 'b') {
                e.preventDefault();
                toggleBackupsPanel();
            }
        });

        // æ˜¾ç¤º/éšè—å¤‡ä»½é¢æ¿
        function toggleBackupsPanel() {
            const panel = document.getElementById('backups-panel');
            panel.classList.toggle('show');
        }

        async function handleFileOpen(handle) {
            try {
                console.log("Opening file:", handle.name);
                fileHandle = handle;
                const file = await fileHandle.getFile();
                const content = await file.text();
                console.log("File content loaded, length:", content.length);
                
                editor.textContent = content;
                // éšè— placeholder
                document.querySelector('.placeholder-text').style.display = 'none';
                
                connectWebSocket(fileHandle.name);
                startFileSync();
                updateBackupList();
                
                // æ˜¾ç¤ºå¿«æ·é”®æç¤º
                const tip = document.getElementById('shortcut-tip');
                tip.classList.add('show');
                setTimeout(() => {
                    tip.classList.remove('show');
                }, 3000);
            } catch (err) {
                console.error("Error opening file:", err);
                alert("Failed to open file: " + err.message);
            }
        }

        // æ‹–æ”¾å¤„ç†
        editor.ondragover = (e) => {
            e.preventDefault();
            editor.classList.add('dragover');
        };
        
        editor.ondragleave = () => {
            editor.classList.remove('dragover');
        };
        
        editor.ondrop = async (e) => {
            e.preventDefault();
            editor.classList.remove('dragover');
            
            if (e.dataTransfer.items) {
                const item = e.dataTransfer.items[0];
                if (item.kind === 'file') {
                    try {
                        const handle = await item.getAsFileSystemHandle();
                        if (handle.kind === 'file') {
                            await handleFileOpen(handle);
                        }
                    } catch (err) {
                        console.error('Error opening dropped file:', err);
                    }
                }
            }
        };

        // æ–‡ä»¶åŒæ­¥
        async function startFileSync() {
            if (syncInterval) clearInterval(syncInterval);

            async function sync() {
                if (!fileHandle) return;
                
                try {
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    
                    if (content !== lastContent) {
                        lastContent = content;
                        if (content !== editor.textContent) {
                            isUpdating = true;
                            editor.textContent = content;
                            if (ws?.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: "edit",
                                    content: content
                                }));
                            }
                            setTimeout(() => isUpdating = false, 100);
                        }
                    }

                    const timeSinceLastEdit = Date.now() - lastEditTime;
                    if (timeSinceLastEdit > 10000 && currentSyncInterval !== INTERVALS.INACTIVE) {
                        currentSyncInterval = INTERVALS.INACTIVE;
                        restartSync();
                    }
                } catch (err) {
                    console.error('Error syncing file:', err);
                }
            }

            function restartSync() {
                clearInterval(syncInterval);
                syncInterval = setInterval(sync, currentSyncInterval);
            }

            restartSync();
        }

        // WebSocketè¿æ¥å¤„ç†
        function connectWebSocket(fileId) {
            if (ws) ws.close();

            ws = new WebSocket(`ws://${window.location.host}/ws/${encodeURIComponent(fileId)}`);
            
            ws.onopen = () => {
                editor.disabled = false;
                showStatus(true);
            };

            ws.onclose = () => {
                editor.disabled = true;
                showStatus(false);
                // æ˜¾ç¤º placeholder
                document.querySelector('.placeholder-text').style.display = 'block';
                setTimeout(() => {
                    if (fileHandle) connectWebSocket(fileHandle.name);
                }, 3000);
            };

            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                if (data.type === "shutdown") {
                    alert("æœåŠ¡å™¨å³å°†å…³é—­ï¼Œè¯·ä¿å­˜æ‚¨çš„æ›´æ”¹");
                    // è‡ªåŠ¨ä¿å­˜å½“å‰å†…å®¹
                    if (fileHandle) {
                        try {
                            const writable = await fileHandle.createWritable();
                            await writable.write(editor.textContent);
                            await writable.close();
                        } catch (err) {
                            console.error('Error saving file before shutdown:', err);
                        }
                    }
                    return;
                }
                if (data.type === "update" && !isUpdating) {
                    try {
                        const currentFile = await fileHandle.getFile();
                        const currentContent = await currentFile.text();
                        if (currentContent !== editor.textContent) {
                            if (!confirm("æ–‡ä»¶å·²è¢«å…¶ä»–ç¨‹åºä¿®æ”¹ï¼Œæ˜¯å¦è¦†ç›–æœ¬åœ°æ›´æ”¹ï¼Ÿ")) {
                                return;
                            }
                        }
                        const writable = await fileHandle.createWritable();
                        await writable.write(data.content);
                        await writable.close();
                        editor.textContent = data.content;
                    } catch (err) {
                        console.error('Error handling file update:', err);
                    }
                }
            };
        }

        // æ·»åŠ å·®å¼‚è®¡ç®—å‡½æ•°
        function calculateDiff(oldContent, newContent) {
            // ç®€å•çš„å·®å¼‚æ£€æµ‹ï¼Œè¿”å›å˜æ›´çš„å¼€å§‹ä½ç½®å’Œå†…å®¹
            let start = 0;
            while (start < oldContent.length && 
                   start < newContent.length && 
                   oldContent[start] === newContent[start]) {
                start++;
            }
            
            let end = 0;
            while (end < oldContent.length - start && 
                   end < newContent.length - start && 
                   oldContent[oldContent.length - 1 - end] === newContent[newContent.length - 1 - end]) {
                end++;
            }
            
            return {
                start,
                content: newContent.slice(start, newContent.length - end),
                oldLength: oldContent.length
            };
        }

        // ä¿®æ”¹ç¼–è¾‘å™¨è¾“å…¥å¤„ç†
        // editor.oninput = async () => 
        editor.addEventListener('input', async (e) => {
            if (!fileHandle || !ws || ws.readyState !== WebSocket.OPEN) return;
            
            lastEditTime = Date.now();
            updateSyncInterval();

            clearTimeout(typingTimer);
            typingTimer = setTimeout(async () => {
                try {
                    const newContent = editor.textContent;
                    const file = await fileHandle.getFile();
                    const oldContent = await file.text();
                    
                    // è®¡ç®—æ–‡ä»¶å¤§å°
                    const fileSize = newContent.length;
                    const isLargeFile = fileSize > 1000000; // 1MB
                    
                    // è®¡ç®—å†…å®¹å·®å¼‚
                    const diff = calculateDiff(oldContent, newContent);
                    const isDiffSmall = diff.content.length < 1000; // å°äº1KBçš„ä¿®æ”¹
                    
                    // æ ¹æ®æ–‡ä»¶å¤§å°å’Œä¿®æ”¹é‡é€‰æ‹©åŒæ­¥ç­–ç•¥
                    if (isLargeFile) {
                        if (isDiffSmall) {
                            // å¤§æ–‡å°ä¿®æ”¹ï¼šå¢é‡åŒæ­¥
                            await sendIncrementalUpdate(diff);
                        } else {
                            // å¤§æ–‡ä»¶å¤§ä¿®æ”¹ï¼šåˆ†å—åŒæ­¥
                            await sendChunkedUpdate(newContent);
                        }
                    } else {
                        // å°æ–‡ä»¶ï¼šç›´æ¥åŒæ­¥
                        await sendFullUpdate(newContent);
                    }
                    
                } catch (err) {
                    console.error('Error syncing file:', err);
                }
            }, 300);
        });

        // å¢é‡æ›´æ–°
        async function sendIncrementalUpdate(diff) {
            // å…ˆæ›´æ–°æœ¬åœ°æ–‡ä»¶
            const writable = await fileHandle.createWritable();
            await writable.seek(diff.start);
            await writable.write(diff.content);
            await writable.close();
            
            // å‘é€å¢é‡æ›´æ–°
            ws.send(JSON.stringify({
                type: "incremental_edit",
                start: diff.start,
                content: diff.content,
                oldLength: diff.oldLength
            }));
        }

        // åˆ†å—æ›´æ–°
        async function sendChunkedUpdate(content) {
            const chunkSize = 500000; // 500KB
            const chunks = Math.ceil(content.length / chunkSize);
            
            // å…ˆæ›´æ–°æœ¬åœ°æ–‡ä»¶
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
            
            // å‘é€åˆ†å—æ›´æ–°
            ws.send(JSON.stringify({
                type: "chunked_edit_start",
                totalChunks: chunks,
                totalSize: content.length
            }));
            
            for (let i = 0; i < chunks; i++) {
                ws.send(JSON.stringify({
                    type: "chunked_edit_chunk",
                    chunk: i,
                    content: content.slice(i * chunkSize, (i + 1) * chunkSize)
                }));
            }
        }

        // å®Œæ•´æ›´æ–°
        async function sendFullUpdate(content) {
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
            
            ws.send(JSON.stringify({
                type: "edit",
                content: content
            }));
        }

        function showStatus(connected) {
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }

        // ä¼˜åŒ–åŒæ­¥é—´éš”æ›´æ–°é€»è¾‘
        function updateSyncInterval() {
            const timeSinceLastEdit = Date.now() - lastEditTime;
            let newInterval = INTERVALS.INACTIVE;
            
            if (timeSinceLastEdit < 3000) {
                newInterval = INTERVALS.TYPING;
            } else if (timeSinceLastEdit < 30000) {
                newInterval = INTERVALS.ACTIVE;
            } else if (timeSinceLastEdit < 300000) {
                newInterval = INTERVALS.IDLE;
            }

            if (newInterval !== currentSyncInterval) {
                currentSyncInterval = newInterval;
                startFileSync();  // é‡å¯åŒæ­¥å®šæ—¶å™¨
            }
        }

        async function createBackup() {
            if (!fileHandle) return;
            const file = await fileHandle.getFile();
            const content = await file.text();
            const timestamp = new Date().toISOString();
            localStorage.setItem(`backup_${fileHandle.name}_${timestamp}`, content);
            updateBackupList();
        }

        function updateBackupList() {
            const backupList = document.getElementById('backup-list');
            backupList.innerHTML = '';
            
            if (!fileHandle) return;
            
            // è·å–å½“å‰æ–‡ä»¶çš„æ‰€æœ‰å¤‡ä»½
            const backups = Object.keys(localStorage)
                .filter(key => key.startsWith(`backup_${fileHandle.name}_`))
                .sort()
                .reverse();
            
            backups.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                const date = new Date(key.split('_')[2]);
                option.textContent = date.toLocaleString(); // æ›´å‹å¥½çš„æ—¶é—´æ ¼å¼
                backupList.appendChild(option);
            });
        }

        async function restoreBackup() {
            const backupList = document.getElementById('backup-list');
            const selectedKey = backupList.value;
            if (!selectedKey || !fileHandle) return;
            
            const content = localStorage.getItem(selectedKey);
            if (content) {
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                editor.textContent = content;
            }
        }

        // å®šæœŸåˆ›å»ºå¤‡ä»½ï¼ˆæ¯5åˆ†é’Ÿï¼‰
        setInterval(createBackup, 5 * 60 * 1000);
    </script>
</body>
</html>